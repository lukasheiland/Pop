---
output:
  pdf_document: default
  html_document: default
---
# ba Recovery

```{r setup, include=FALSE}
library(readr)
library(rstan)
library(here)
library(parallel)

knitr::opts_knit$set(root.dir = here())
setwd(here()) # For Rstudio, which apparently ignores opts_knit for inline chunk runs
modeldir <- dir(pattern = "^(Model).*ba$")
recoverydir <- file.path(modeldir, "Sim_ba_recovery")

source(file.path(modeldir, "Sim_ba_functions.R"), local = knitr::knit_global())
source(file.path(modeldir, "Sim_ba_recovery_functions.R"), local = knitr::knit_global())
source(file.path(modeldir, "Sim_ba_recovery_functions.R"), local = knitr::knit_global())
source(file.path(modeldir, "Fit_ba_functions.R"), local = knitr::knit_global())
source(file.path(modeldir, "Fit_ba_test_functions.R"), local = knitr::knit_global())

```

## Introduction

Here, permutations of
    1. 3 different parameter sets,
    2. differently wide priors,
    3. different amounts of data points close to equilibrium in the data.
    

| Prior factor | s) Shading-driven                                   | g) Growth-driven | c) Competition-driven |
|--------------|-----------------------------------------------------|------------------|-----------------------|
| 1            | s1, s1_mixed, s1_climax                             | g1               | c1                    |
| 10           | s2, s2_mixed, s2_climax                             | g2               | c2                    |
| 100          | s3, s3_mixed, s3_climax                             | g3               | c3                    |
|                (S with three different variants on fix point data)                                            |


```{r, echo=FALSE}
# str(parametersets, max.level = 1)

# formals(generateParameters)

parseed <- 3
parametersets <- list(s = generateParameters(seed = parseed, n_species = 2, n_locs = 200, s_log = c(-2, -0.1), r_log = c(2, 2.1)), # first sepcies is less affected by shading
                      g = generateParameters(parseed, 2, n_locs = 200, g_logit = c(0.5, -0.5), h_logit = c(0.5, -0.5), b_log = c(-0.5, -1), r_log = c(2, 2.1)), # first species grows faster
                      c = generateParameters(parseed, 2, n_locs = 200, c_j_log = c(-1.5, -0.5), c_b_log = c(-1.5, -0.5), s_log = c(-3, -3), r_log = c(2, 2.1)) # # first species is less affected by competiton
                     )

timesets <- list(perturbed = c(1, 2, 4), mixed = c(2, 3, 5), climax = c(20, 40, 60)) # in addition to slightly later times, mixed has ragged times internally

Env <- simulateEnv(n_env = parametersets[[1]]$n_env, n_locs = parametersets[[1]]$n_locs)
envdependent <- c(b = F, c_a = F, c_b = F, c_j = T, g = T, h = F, l = T, m_a = F, m_j = F, r = T, s = T)
model <- cmdstan_model(file.path(modeldir, 'Model_ba-rect.stan'))

tasks <- list(
  names = c("s1", "s2", "s3", "g1", "g2", "g3", "c1", "c2", "c3",
            "s1_mixed", "s2_mixed", "s3_mixed",
            "s1_climax", "s2_climax", "s3_climax"),
  pars = parametersets[c(rep(1:3, each = 3), rep(1, 6))],
  times = timesets[c(rep(1, 9), rep(2:3, each = 3))],
  independentstart = as.list(c(rep(F, 9), rep(T, 3), rep(F, 3))),
  priorfactor = as.list(rep(1:3, 5))
)
names(tasks$pars) <- tasks$names
saveRDS(tasks, file.path(recoverydir, "Fits.nosync", "Sim_ba_recovery_tasks.rds"))

# str(tasks, max.level = 1)
# formals(setupRecovery)

setups <- parallel::mcmapply(setupRecovery,
                 pars = tasks$pars, times = tasks$times, independentstart = tasks$independentstart, priorfactor = tasks$priorfactor,
                 recoveryname = tasks$name,
                 MoreArgs = list(model = model, Env = Env, envdependent = envdependent),
                 mc.cores = getOption("mc.cores", 15),
                 SIMPLIFY = F, USE.NAMES = T) # will use the names of pars1

saveRDS(setups, file.path(recoverydir, "Fits.nosync", "Sim_ba_allsetups.rds"))
```

### 1. Three parameter sets

- For illustrations of the parameter sets, singular time series are shown.
- Note that for fitting I used
    - 100 time series
    - with randomly different starting values,
    - randomly different start times, i.e. different amounts of progress
    - start time always > 1 (values far out-of equilibrium are omitted


```{r, echo=FALSE}
## pars have been generated by call: generateParameters(seed = parseed, n_locs = 100, n_species = 2, n_plotsperloc = 4)

# setupbasename1 <- "Model_ba-rect-202105071722"
# setup1 <- readRDS(file.path(rootdir, "Fits.nosync", "Recovery", paste0(setupbasename1, ".rds")))

pars_s <- tasks$pars$s1
pars_g <- tasks$pars$g1
pars_c <- tasks$pars$c1


plotOneSeries <- function(Sim) {
  n_species <- (ncol(Sim) - 1)/3
  matplot(Sim[,-1], type = "b", ylab="N",
        pch = rep(c("J", "A", "B"), each = n_species),
        col = 1:n_species, xlab = "time") # log='y'
}


par(mfrow = c(2,2))
Sim_s <- simulateOneSeries(state_init = generateInitialState(n_species = pars_s$n_species),
                           times = 1:10, pars = pars_s,
                           processerror = F, obserror = F)
plotOneSeries(Sim_s)

simulateOneSeries(state_init = generateInitialState(n_species = pars_g$n_species),
                           times = 1:10, pars = pars_g,
                           processerror = F, obserror = F) %>%
  plotOneSeries()

simulateOneSeries(state_init = generateInitialState(n_species = pars_c$n_species),
                           times = 1:10, pars = pars_c,
                           processerror = F, obserror = F) %>%
  plotOneSeries()
par(mfrow = c(1,1))

```

- black: species 1, red: species 2.


### 2. Differently wide priors
- priors are automatically generated: ~ normal(mu_true_log, mu_true_log + log(priorfactor))

### 3. Amount of fix point data
- Varying amounts of fix point data are achieved by selecting different times for fitting after the initial values


- That data far from equilibrium gives better fit is also corrobarated by fits with exponential growth (parameter configuration with c_j and also accidentally c_b set to 0 leading to exponential growth in B)

## Tests

### How well do predictions work?
- Good: Always work pretty well
- 3x3 matrix of RMSE with all parameters

### How well are parameters recovered depending on prior width
 - 3x3 matrix of RMSE
- pairs plot with priors

#### Seems like, Model, as is, needs strong priors for convergence
- ("b_log", "c_b_log", "g_logit", "h_logit", "r_log", "s_log" )
- which is fine for inference if
    - we use a common prior for both species for most parameters: l, g, r, s, c_*
    - and a species-specific prior directly measured from the data: b, h
    
#### Correlation between parameters
- IN GENERAL: Closely coupled parameters with opposite effects are not MARGINALLY identifiable here, even though they are differently dependent on the sum of all (c_b) and single species (b). (also r and s).


#### Equifinality
- In general, it looks like there is equifinality in the model: data can arise from multiple parameter configurations, i.e. trade-offs in parameter space

- this leads to the pattern: "while the marginal posteriors look flat or like the prior, the the multivariate posterior space is smaller than the multivariate prior space" (i.e. you see correlations between the parameters that were not in the prior). See https://bg.copernicus.org/articles/11/1261/2014/bg-11-1261-2014-supplement.pdf (and https://stats.stackexchange.com/questions/176436/what-would-be-the-reason-that-the-posterior-distribution-looks-like-the-prior-us)

- but this means of course: true parameters should be recovered within the posteriors, but not necessarily at their centers

#### Power of the tests right?
- QUESTION: Although the marginal posterior distributions are wide, can't I still test all of the hypotheses in question (e.g. relative magnitude of rates in certain environments) from checks on the conditional posteriors?
    - with c_j included?
- Here, we just want to recover the tests, not the marginal parameters


### How well are parameters recovered depending on amount on equilibrium data






## Old Recovery notes

```{r}
stanfit1 <- rstan::read_stan_csv(file.path(rootdir, "Fits.nosync", "Recovery", setup1$drawfile))
draws1 <- rstan::extract(stanfit1)

plotPredictedVsTrue(draws1, setup1$data)

```


```{r, warning=FALSE, results='hide', out.width="30%", dev='png'}

## here are the drawn parameters:
setup1$metadata$stan_variables

plotEstimateVsTrue(parname = "b_log", simdata = setup1$data, stanfit = stanfit1)
plotEstimateVsTrue("c_j_log", setup1$data, stanfit1)
# plotEstimateVsTrue("c_b_log", setup1$data, stanfit1)
plotEstimateVsTrue("g_logit", setup1$data, stanfit1)
# plotEstimateVsTrue("h_logit", setup1$data, stanfit1) # best recovery
plotEstimateVsTrue("r_log", setup1$data, stanfit1)
plotEstimateVsTrue("s_log", setup1$data, stanfit1)

```

```{r, out.width='\\textwidth', fig.height = 8, fig.align='center', results=FALSE, warning=FALSE, dev='png'}
## plot correlations
setup1$metadata$stan_variables
corpars_a <- setup1$metadata$stan_variables[c(1, 2, 3, 6, 7)]
corpars_b <- setup1$metadata$stan_variables[c(2, 4, 5, 7, 8)]

pairs(stanfit1, pars = corpars_a)
pairs(stanfit1, pars = corpars_b)


```

- "lp_" is the variable part of the log-likelihood

```{r, out.width='\\textwidth', fig.height = 8, fig.align='center', results=FALSE, warning=FALSE, echo=FALSE, dev='png'}
## plot correlations
setup6$metadata$stan_variables
corpars_a <- setup6$metadata$stan_variables[c(1, 2, 3, 6, 7)]
corpars_b <- setup6$metadata$stan_variables[c(2, 3, 5, 7, 8)]

pairs(stanfit6, pars = corpars_a)
pairs(stanfit6, pars = corpars_b)

# plotStatePairs(data)
```


#### Observations Setup1, Vanillla
- g and c_j are closely correlated. This is probably because sum(J) and sum(A) are also closely coupled, so that we have a "confounding" structure here?
- this could lead to unidentifiability
- maybe this could actually be circumvented by fitting a full matrix based on species effects, instead of based on the total abundance of all species

- Setup 1: including c_j
    - no recovery at all
    - positive: c_j_log[1] ~ r_log[1] dominant species!
    - positive: c_b_log ~ b_log
    - positive: b_log[2] ~ g_log[2] subordinate species!

    - although b and r are dependent on species state and c are on the sum, they are highly correlated


#### Observations Setup 2

- Setup 2: c_j set all c to 0, accidentally exp growth in B
    - this gets rid of the biggerst problem, that c_b and r/b are similarly dependent on state, but:
    - positive r_log ~ s_log remains (similar situation, only lag through state transition)



#### Observations Setup 3
- Parameter configuration with c_j set to 0

- Setup 3: c_j set 0 (c_b limitation present)
    - reintroduces the good model, but also the problem
    - positive c_b ~ b ~ g (within species!)
    - especially positive: c_b_log[2] ~ g_log[2] subordinate species!

    - positive s ~ r


#### Observations Setup 4

- less J-dominated, s >> c_b
- with wider priors
    - common prior for most parameters
    - those for which a species-relative prior can be directly measured from the data: differentiated by species: b, h
    
- Setup 4: c_j set 0 (c_b )
    - here, the recovery seems to be completely broken. Probably error, in prior specification because they weren't checked!
    - all the same correlations
        - positive c_b ~ b ~ g (within species!)
        - positive r_log ~ s_log (within species)

#### Observations Setup 5
- more different parameters per species

- Setup 5:
    - MORE DIFFERENT PARAMETERS
    - Better recovery
    - all the same correlations
        - positive c_b ~ b (within species!)
        - positive r_log ~ s_log (within species)


#### Setup 6
- like 5 but with data mainly before equilibrium (used unragged times 1:3)
- NICE!




## Further unsystematic recovery experience

### Possible problems with the discrete model
- suspicion: with state independent r == l the system might not be identifiable in equilibrium!
- with some parameter-configurations the discrete model has periodic fluctuations on the same scale as the error

### Times
- just increasing the number of re-observations per time series does not always improve the fit dramatically
- (but in some cases it did)

### Regularization in hierarchical models

#### Constraints for sigma in lognormal
- These are notes from a former version with lognormal random demographic rates:
    - lognormal is fucked up because with big sigmas the mean gets highly biased towards greater values
        - Model gets ill-specified if sigma_par is not pushed towards 0
        - but regularization will introduce significant bias
        - => very soft prior sigma ~ normal(0, 1) [truncated]

#### Constraints for phi in negbinomial
- Really tight regularization on the observation error dispersion in phi_obs for recovery
- When in doubt, go tighter (higher): inv_phi_obs ~ normal(0, 0.001);
 
