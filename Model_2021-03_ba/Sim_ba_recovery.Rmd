---
output:
  pdf_document: default
  html_document: default
---
# ba Recovery

```{r setup, include=FALSE}
library(readr)
library(rstan)

rootdir <- ".." # knitr uses current location as wd

## source first part of Sim
setwd(rootdir) # only temporarily for textConnection
source(file.path("Model_2021-03_ba", "Sim_ba_helpers.R"), local = knitr::knit_global())
sartkeypattern = "# startsource"
stopkeypattern = "# endsource"
lines <- read_lines(file.path("Model_2021-03_ba", "Sim_ba.R"))
startline <- grep(sartkeypattern, lines)
stopline <- grep(stopkeypattern, lines)
lines_collapsed <- paste(lines[startline:stopline], collapse='\n')
source(textConnection(lines_collapsed), local = TRUE)
source(file.path("Recovery_functions.R"), local = knitr::knit_global())

```



## Simulation and Paramater sets

- For illustrations of the parameter sets, singular time series are shown.
- Note that for fitting I used
    - 100 time series
    - with randmoly different starting values,
    - randomly different start times, i.e. different amounts of progress
    - start time always > 1 (values far out-of equilibrium are omitted

- black: species 1, red: species 2.
- **Setups 1 - 4 ** have included a varying but fixed input ldd.
  

### Setup 1

- Standard parameter configuration with expected results


```{r, echo=FALSE}
## pars have been generated by call: generateParameters(seed = parseed, n_locs = 100, n_species = 2, n_plotsperloc = 4)

setupbasename1 <- "Model_ba-rect-202105071722"
setup1 <- readRDS(file.path(rootdir, "Fits.nosync", "Recovery", paste0(setupbasename1, ".rds")))
pars1 <- within(setup1$truepars, { m_a <- 0;  m_j <- 0})
initialstate1 <- generateInitialState(n_species = pars1$n_species)
times1 <- 3:20

Sim1 <- simulateOneSeries(initialstate1, times = times1, pars = pars1,
                          processerror = F, obserror = F)

matplot(Sim1[,-1], type = "b", ylab="N",
        pch = rep(c("J", "A", "B"), each = pars1$n_species),
        col = 1:pars1$n_species, xlab = "time") # log='y'
```


```{r}
stanfit1 <- rstan::read_stan_csv(file.path(rootdir, "Fits.nosync", "Recovery", setup1$drawfile))
draws1 <- rstan::extract(stanfit1)

plotPredictedVsTrue(draws1, setup1$data)

```


```{r, warning=FALSE, results='hide', out.width="30%", dev='png'}

## here are the drawn parameters:
setup1$metadata$stan_variables

plotEstimateVsTrue(parname = "b_log", simdata = setup1$data, stanfit = stanfit1)
plotEstimateVsTrue("c_j_log", setup1$data, stanfit1)
# plotEstimateVsTrue("c_b_log", setup1$data, stanfit1)
plotEstimateVsTrue("g_logit", setup1$data, stanfit1)
# plotEstimateVsTrue("h_logit", setup1$data, stanfit1) # best recovery
plotEstimateVsTrue("r_log", setup1$data, stanfit1)
plotEstimateVsTrue("s_log", setup1$data, stanfit1)

```

```{r, out.width='\\textwidth', fig.height = 8, fig.align='center', results=FALSE, warning=FALSE, dev='png'}
## plot correlations
setup1$metadata$stan_variables
corpars_a <- setup1$metadata$stan_variables[c(1, 2, 3, 6, 7)]
corpars_b <- setup1$metadata$stan_variables[c(2, 4, 5, 7, 8)]

pairs(stanfit1, pars = corpars_a)
pairs(stanfit1, pars = corpars_b)


```

- "lp_" is the variable part of the log-likelihood

#### Observations
- g and c_j are closely correlated. This is probably because sum(J) and sum(A) are also closely coupled, so that we have a "confounding" structure here?
- this could lead to unidentifiability
- maybe this could actually be circumvented by fitting a full matrix based on species effects, instead of based on the total abundance of all species



### Setup 2

- Parameter configuration with c_j (and also accidentally c_b) set to 0 leading to exponential growth in B
- good recovery

```{r, echo=FALSE}

## Same parameters as above but with hard reset of c tp 0

# calcModelWrapper <- function(times, initialstate, pars, ...) { 
#   
#   calcModel(times, initialstate,
#             within(pars, { m_a <- 0;  m_j <- 0; c_j <- 0; c_a <- 0; c_b <- 0}), # l <- 0;
#             ...)
#   }

setupbasename2 <- "Model_ba-rect-202105080028"
setup2 <- readRDS(file.path(rootdir, "Fits.nosync", "Recovery", paste0(setupbasename2, ".rds")))
pars2 <- within(setup2$truepars, { m_a <- 0;  m_j <- 0; c_j <- 0; c_a <- 0; c_b <- 0})
initialstate2 <- generateInitialState(n_species = pars2$n_species)
times2 <- 1:15

Sim2 <- simulateOneSeries(initialstate2, times = times2, pars = pars2,
                          processerror = F, obserror = F)

matplot(Sim2[,-1], type = "b", ylab="N",
        pch = rep(c("J", "A", "B"), each = pars2$n_species),
        col = 1:pars2$n_species, xlab = "time") # log='y'

```


```{r, echo=FALSE}
stanfit2 <- rstan::read_stan_csv(file.path(rootdir, "Fits.nosync", "Recovery", setup2$drawfile))
draws2 <- rstan::extract(stanfit2)

plotPredictedVsTrue(draws2, setup2$data)

```


```{r, warning=FALSE, results='hide', echo=FALSE, out.width="30%", dev='png'}
## here are the drawn parameters:
setup2$metadata$stan_variables

plotEstimateVsTrue(parname = "b_log", simdata = setup2$data, stanfit = stanfit2)
# plotEstimateVsTrue("c_j_log", setup2$data, stanfit2) ## was set to 0, here sampled freely
# plotEstimateVsTrue("c_b_log", setup2$data, stanfit2)  ## was set to 0, here sampled freely
plotEstimateVsTrue("g_logit", setup2$data, stanfit2)
plotEstimateVsTrue("h_logit", setup2$data, stanfit2) # best recovery
plotEstimateVsTrue("r_log", setup2$data, stanfit2)
plotEstimateVsTrue("s_log", setup2$data, stanfit2)

```



```{r, out.width='\\textwidth', fig.height = 8, fig.align='center', results=FALSE, warning=FALSE, echo=FALSE, dev='png'}
## plot correlations
setup2$metadata$stan_variables
corpars_a <- setup2$metadata$stan_variables[c(1, 2, 6, 7)]
corpars_b <- setup2$metadata$stan_variables[c(2, 5, 7, 8)]

pairs(stanfit2, pars = corpars_a)
pairs(stanfit2, pars = corpars_b)


```



### Setup 3

- Parameter configuration with c_j set to 0

```{r}

## Same parameters as above but with hard reset of c tp 0

calcModelWrapper <- function(times, initialstate, pars, ...) { 
  
  calcModel(times, initialstate,
            within(pars, { m_a <- 0;  m_j <- 0; c_j <- 0; c_a <- 0;}), # l <- 0;
            ...)
  }

setupbasename3 <- "Model_ba-rect-202105081104"
setup3 <- readRDS(file.path(rootdir, "Fits.nosync", "Recovery", paste0(setupbasename3, ".rds")))
pars3 <- within(setup3$truepars, { m_a <- 0;  m_j <- 0; c_j <- 0; c_a <- 0})
initialstate3 <- generateInitialState(n_species = pars3$n_species)
times3 <- 1:10

Sim3 <- simulateOneSeries(initialstate3, times = times3, pars = pars3,
                          processerror = F, obserror = F)

matplot(Sim3[,-1], type = "b", ylab="N",
        pch = rep(c("J", "A", "B"), each = pars3$n_species),
        col = 1:pars3$n_species, xlab = "time") # log='y'

```


```{r, echo=FALSE}
stanfit3 <- rstan::read_stan_csv(file.path(rootdir, "Fits.nosync", "Recovery", setup3$drawfile))
draws3 <- rstan::extract(stanfit3)

plotPredictedVsTrue(draws3, setup3$data)

```


```{r, warning=FALSE, results='hide', echo=FALSE, out.width="30%", dev='png'}
## here are the drawn parameters:
setup3$metadata$stan_variables

plotEstimateVsTrue(parname = "b_log", simdata = setup3$data, stanfit = stanfit3)
plotEstimateVsTrue("c_b_log", setup3$data, stanfit3)
plotEstimateVsTrue("g_logit", setup3$data, stanfit3)
plotEstimateVsTrue("h_logit", setup3$data, stanfit3) # best recovery
plotEstimateVsTrue("r_log", setup3$data, stanfit3)
plotEstimateVsTrue("s_log", setup3$data, stanfit3)

```


```{r, out.width='\\textwidth', fig.height = 8, fig.align='center', results=FALSE, warning=FALSE, echo=FALSE, dev='png'}
## plot correlations
setup3$metadata$stan_variables
corpars_a <- setup3$metadata$stan_variables[c(1, 2, 3, 5, 6)]
corpars_b <- setup3$metadata$stan_variables[c(2, 3, 4, 6, 7)]

pairs(stanfit3, pars = corpars_a)
pairs(stanfit3, pars = corpars_b)


```




### Setup 4

- less J-dominated, s >> c_b
- with wider priors
    - common prior for most parameters
    - those for which a species-relative prior can be directly measured from the data: differentiated by species: b, h

```
  b_log ~ normal([0.3, 0.4], 0.1);
  h_logit ~ normal([0.4, 0.5], 0.1);
  
  g_logit ~ normal(-0.9, 1);
  r_log ~ normal(3, 1);
  s_log ~ normal(-1, 1);
```

```{r}

## Same parameters as above but with hard reset of c to 0

setupbasename4 <- "Model_ba-rect-202105081530"
setup4 <- readRDS(file.path(rootdir, "Fits.nosync", "Recovery", paste0(setupbasename4, ".rds")))
pars4 <- within(setup4$truepars, { m_a <- 0;  m_j <- 0; c_j <- 0; c_a <- 0;})
initialstate4 <- generateInitialState(n_species = pars4$n_species)
times4 <- 1:10

Sim4 <- simulateOneSeries(initialstate4, times = times4, pars = pars4,
                          processerror = F, obserror = F)

matplot(Sim4[,-1], type = "b", ylab="N",
        pch = rep(c("J", "A", "B"), each = pars4$n_species),
        col = 1:pars4$n_species, xlab = "time") # log='y'

```


```{r, echo=FALSE}
stanfit4 <- rstan::read_stan_csv(file.path(rootdir, "Fits.nosync", "Recovery", setup4$drawfile))
draws4 <- rstan::extract(stanfit4)

plotPredictedVsTrue(draws4, setup4$data)

```


```{r, warning=FALSE, results='hide', echo=FALSE, out.width="30%", dev='png'}
## here are the drawn parameters:
setup4$metadata$stan_variables

plotEstimateVsTrue(parname = "b_log", simdata = setup4$data, stanfit = stanfit4)
plotEstimateVsTrue("c_b_log", setup4$data, stanfit4)
plotEstimateVsTrue("g_logit", setup4$data, stanfit4)
plotEstimateVsTrue("h_logit", setup4$data, stanfit4) # best recovery
plotEstimateVsTrue("r_log", setup4$data, stanfit4)
plotEstimateVsTrue("s_log", setup4$data, stanfit4)

```



```{r, out.width='\\textwidth', fig.height = 8, fig.align='center', results=FALSE, warning=FALSE, echo=FALSE, dev='png'}
## plot correlations
setup4$metadata$stan_variables
corpars_a <- setup4$metadata$stan_variables[c(1, 2, 3, 5, 6)]
corpars_b <- setup4$metadata$stan_variables[c(2, 3, 4, 6, 7)]

pairs(stanfit4, pars = corpars_a)
pairs(stanfit4, pars = corpars_b)


```



### Setup 5
- more different parameters per species

```{r}

## Same parameters as above but with hard reset of c tp 0

setupbasename5 <- "Model_ba-rect-202105122308"
setup5 <- readRDS(file.path(rootdir, "Fits.nosync", "Recovery", paste0(setupbasename5, ".rds")))
pars5 <- within(setup5$truepars, { m_a <- 0;  m_j <- 0; c_j <- 0; c_a <- 0})
initialstate5 <- generateInitialState(n_species = pars5$n_species)
times5 <- seq(1:10)

Sim5 <- simulateOneSeries(initialstate5, times = times5, pars = pars5,
                          processerror = F, obserror = F)

matplot(Sim5[,-1], type = "b", ylab="N",
        pch = rep(c("J", "A", "B"), each = pars5$n_species),
        col = 1:pars5$n_species, xlab = "time") # log='y'

```


```{r, echo=FALSE}
stanfit5 <- rstan::read_stan_csv(file.path(rootdir, "Fits.nosync", "Recovery", setup5$drawfile))
draws5 <- rstan::extract(stanfit5)

plotPredictedVsTrue(draws5, setup5$data) # does not work because of data fuckup

```


```{r, warning=FALSE, results='hide', echo=FALSE, out.width="30%"}
## here are the drawn parameters:
setup5$metadata$stan_variables

plotEstimateVsTrue(parname = "b_log", simdata = setup5$data, stanfit = stanfit5)
plotEstimateVsTrue("c_b_log", setup5$data, stanfit5)
plotEstimateVsTrue("g_logit", setup5$data, stanfit5)
plotEstimateVsTrue("h_logit", setup5$data, stanfit5) # best recovery
plotEstimateVsTrue("r_log", setup5$data, stanfit5)
plotEstimateVsTrue("s_log", setup5$data, stanfit5)

```



```{r, out.width='\\textwidth', fig.height = 8, fig.align='center', results=FALSE, warning=FALSE, echo=FALSE, dev='png'}
## plot correlations
setup5$metadata$stan_variables
corpars_a <- setup5$metadata$stan_variables[c(1, 2, 3, 6, 7)]
corpars_b <- setup5$metadata$stan_variables[c(2, 3, 5, 7, 8)]

pairs(stanfit5, pars = corpars_a)
pairs(stanfit5, pars = corpars_b)


```






### Setup 6
- like 5 but with data mainly before equilibrium (used unragged times 1:3)

```{r}

## Same parameters as above but with hard reset of c tp 0

setupbasename6 <- "Model_ba-rect-202105182155"
setup6 <- readRDS(file.path(rootdir, "Fits.nosync", "Recovery", paste0(setupbasename6, ".rds")))
pars6 <- within(setup6$truepars, {m_a <- 0;  m_j <- 0;})
initialstate6 <- generateInitialState(n_species = pars6$n_species)
times6 <- seq(1:8)

Sim6 <- simulateOneSeries(initialstate6, times = times6, pars = pars6,
                          processerror = F, obserror = F)

matplot(Sim6[,-1], type = "b", ylab="N",
        pch = rep(c("J", "A", "B"), each = pars6$n_species),
        col = 1:pars6$n_species, xlab = "time") # log='y'

# plotTimeSeries(setup6$data$Long)

```


```{r, echo=FALSE, dev='png'}
stanfit6 <- rstan::read_stan_csv(file.path(rootdir, "Fits.nosync", "Recovery", setup6$drawfile))
draws6 <- rstan::extract(stanfit6)

plotPredictedVsTrue(draws6, setup6$data)

```


```{r, warning=FALSE, results='hide', echo=FALSE, out.width="30%"}
## here are the drawn parameters:
setup6$metadata$stan_variables

plotEstimateVsTrue(parname = "b_log", simdata = setup6$data, stanfit = stanfit6)
plotEstimateVsTrue("c_b_log", setup6$data, stanfit6)
plotEstimateVsTrue("g_logit", setup6$data, stanfit6)
plotEstimateVsTrue("h_logit", setup6$data, stanfit6) # best recovery
plotEstimateVsTrue("r_log", setup6$data, stanfit6)
plotEstimateVsTrue("s_log", setup6$data, stanfit6)

```



```{r, out.width='\\textwidth', fig.height = 8, fig.align='center', results=FALSE, warning=FALSE, echo=FALSE, dev='png'}
## plot correlations
setup6$metadata$stan_variables
corpars_a <- setup6$metadata$stan_variables[c(1, 2, 3, 6, 7)]
corpars_b <- setup6$metadata$stan_variables[c(2, 3, 5, 7, 8)]

pairs(stanfit6, pars = corpars_a)
pairs(stanfit6, pars = corpars_b)

# plotStatePairs(data)
```




## Model

```
BA <- A * ba_a_avg + B
BA_sum <- sum(BA)

u <- matrix(0, nrow = length(s), ncol = 3) + rnorm(length(s)*3, 0, sigma)

J_trans <- r*BA + l + (J - g*J) # use rlnorm + u[ ,1]
J_t <- J_trans * 1/(1 + c_j*sum(J) + s*BA_sum + m_j) # count of juveniles J

A_trans <- g*J + (A - h*A) # + u[ ,2]
A_t <-  A_trans * 1/(1 + c_b*BA_sum + m_a) # count of small adults


A_ba <- A * h * ba_a_upper
B_trans <- A_ba + B # + u[ ,3]
B_t <- (1+b)*B_trans * 1/(1 + c_b*BA_sum)
```


## Model, as is, needs strong priors for convergence

("b_log", "c_b_log", "g_logit", "h_logit", "r_log", "s_log" )

- which is fine for inference if
    - we use a common prior for both species for most parameters: l, g, r, s, c_*
    - and a species-specific prior directly measured from the data: b, h

## Correlation notes
- In general, it looks like there is equifinality in the model: data can arise from multiple parameter configurations, i.e. trade-offs in parameter space

- this leads to the pattern: "while the marginal posteriors look flat or like the prior, the the multivariate posterior space is smaller than the multivariate prior space" (i.e. you see correlations between the parameters that were not in the prior). See https://bg.copernicus.org/articles/11/1261/2014/bg-11-1261-2014-supplement.pdf (and https://stats.stackexchange.com/questions/176436/what-would-be-the-reason-that-the-posterior-distribution-looks-like-the-prior-us)

- but this means of course: true parameters should be recovered within the posteriors, but not necessarily at their centers
- or NEXT: conditional recovery tests?


- Setup 1: including c_j
    - no recovery at all
    - positive: c_j_log[1] ~ r_log[1] dominant species!
    - positive: c_b_log ~ b_log
    - positive: b_log[2] ~ g_log[2] subordinate species!

    - although b and r are dependent on species state and c are on the sum, they are highly correlated

- Setup 2: c_j set all c to 0, accidentally exp growth in B
    - this gets rid of the biggerst problem, that c_b and r/b are similarly dependent on state, but:
    - positive r_log ~ s_log remains (similar situation, only lag through state transition)

    
- Setup 3: c_j set 0 (c_b limitation present)
    - reintroduces the good model, but also the problem
    - positive c_b ~ b ~ g (within species!)
    - especially positive: c_b_log[2] ~ g_log[2] subordinate species!

    - positive s ~ r
    
- Setup 4: c_j set 0 (c_b )
    - here, the recovery seems to be completely broken. Probably error, in prior specification because they weren't checked!
    - all the same correlations
        - positive c_b ~ b ~ g (within species!)
        - positive r_log ~ s_log (within species)
        
- Setup 5:
    - MORE DIFFERENT PARAMETERS
    - Better recovery
    - all the same correlations
        - positive c_b ~ b (within species!)
        - positive r_log ~ s_log (within species)

- IN GENERAL: Closely coupled parameters with opposite effects are not MARGINALLY identifiable here, even though they are differently dependent on the sum of all (c_b) and single species (b). (also r and s).

- QUESTION: Although the marginal posterior distributions are wide, can't I still test all of the hypotheses in question (e.g. relative magnitude of rates in certain environments) from checks on the conditional posteriors?
    - with c_j included?

 
## Further unsystematic recovery experience

### Possible problems with the discrete model
- suspicion: with state independent r == l the system might not be identifiable in equilibrium!
- with some parameter-configurations the discrete model has periodic fluctuations on the same scale as the error

### Success
- predictions always work


### Times
- just increasing the number of re-observations per time series does not always improve the fit dramatically
- (but in some cases it did)



### Regularization in hierarchical models

#### Constraints for sigma in lognormal
- These are notes from a former version with lognormal random demographic rates:
    - lognormal is fucked up because with big sigmas the mean gets highly biased towards greater values
        - Model gets ill-specified if sigma_par is not pushed towards 0
        - but regularization will introduce significant bias
        - => very soft prior sigma ~ normal(0, 1) [truncated]

#### Constraints for phi in negbinomial
- Really tight regularization on the observation error dispersion in phi_obs for recovery
- When in doubt, go tighter (higher): inv_phi_obs ~ normal(0, 0.001);
 
