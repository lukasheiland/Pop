---
output:
  pdf_document: default
  html_document: default
---
# ba Recovery

```{r setup, include=FALSE}
library(readr)
library(rstan)

rootdir <- ".." # knitr uses current location as wd

## source first part of Sim
setwd(rootdir) # only temporarily for textConnection
source(file.path("Model_2021-03_ba", "Sim_ba_helpers.R"), local = knitr::knit_global())
sartkeypattern = "# startsource"
stopkeypattern = "# endsource"
lines <- read_lines(file.path("Model_2021-03_ba", "Sim_ba.R"))
startline <- grep(sartkeypattern, lines)
stopline <- grep(stopkeypattern, lines)
lines_collapsed <- paste(lines[startline:stopline], collapse='\n')
source(textConnection(lines_collapsed), local = TRUE)
source(file.path("Recovery_functions.R"), local = knitr::knit_global())

```



## Simulation and Paramater sets

- For illustrations of the parameter sets, singular time series are shown.
- Note that for fitting I used
    - 100 time series
    - with randmoly different starting values,
    - randomly different start times, i.e. different amounts of progress
    - start time always > 1 (values far out-of equilibrium are omitted
  

### Setup 1

- Standard parameter configuration with expected results


```{r, echo=FALSE}
## pars have been generated by call: generateParameters(seed = parseed, n_locs = 100, n_species = 2, n_plotsperloc = 4)

setupbasename1 <- "Model_ba-rect-202105071722"
setup1 <- readRDS(file.path(rootdir, "Fits.nosync", "Recovery", paste0(setupbasename1, ".rds")))
pars1 <- within(setup1$truepars, { m_a <- 0;  m_j <- 0})
initialstate1 <- generateInitialState(n_species = pars1$n_species)
times1 <- 3:20

Sim1 <- simulateOneSeries(initialstate1, times = times1, pars = pars1,
                          processerror = F, obserror = F)

matplot(Sim1[,-1], type = "b", ylab="N",
        pch = rep(c("J", "A", "B"), each = pars1$n_species),
        col = 1:pars1$n_species, xlab = "time") # log='y'
```


```{r}
stanfit1 <- rstan::read_stan_csv(file.path(rootdir, "Fits.nosync", "Recovery", setup1$drawfile))
draws1 <- rstan::extract(stanfit1)

plotPredictedVsTrue(draws1, setup1$data)

```


```{r, warning=FALSE, results='hide'}
## here are the drawn parameters:
setup1$metadata$stan_variables

plotEstimateVsTrue(parname = "b_log", simdata = setup1$data, stanfit = stanfit1)
plotEstimateVsTrue("c_j_log", setup1$data, stanfit1)
# plotEstimateVsTrue("c_b_log", setup1$data, stanfit1)
plotEstimateVsTrue("g_logit", setup1$data, stanfit1)
# plotEstimateVsTrue("h_logit", setup1$data, stanfit1) # best recovery
plotEstimateVsTrue("r_log", setup1$data, stanfit1)
plotEstimateVsTrue("s_log", setup1$data, stanfit1)

```

```{r, out.width='\\textwidth', fig.height = 8, fig.align='center', results=FALSE, warning=FALSE}
## plot correlations
setup1$metadata$stan_variables
corpars_a <- setup1$metadata$stan_variables[c(1, 4, 5, 7)]
corpars_b <- setup1$metadata$stan_variables[c(1, 4, 7, 8)]

pairs(stanfit1, pars = corpars_a)
pairs(stanfit1, pars = corpars_b)


```

- "lp_" is the variable part of the log-likelihood

#### Observations
- g and c_j are closely correlated. This is probably because sum(J) and sum(A) are also closely coupled, so that we have a "confounding" structure here?
- this could lead to unidentifiability
- maybe this could actually be circumvented by fitting a full matrix based on species effects, instead of based on the total abundance of all species



### Setup 2

- Parameter configuration with c_j (and also accidentally c_b) set to 0 leading to exponential growth in B
- good recovery

```{r, echo=FALSE}

## Same parameters as above but with hard reset of c tp 0

# calcModelWrapper <- function(times, initialstate, pars, ...) { 
#   
#   calcModel(times, initialstate,
#             within(pars, { m_a <- 0;  m_j <- 0; c_j <- 0; c_a <- 0; c_b <- 0}), # l <- 0;
#             ...)
#   }

setupbasename2 <- "Model_ba-rect-202105080028"
setup2 <- readRDS(file.path(rootdir, "Fits.nosync", "Recovery", paste0(setupbasename2, ".rds")))
pars2 <- within(setup2$truepars, { m_a <- 0;  m_j <- 0; c_j <- 0; c_a <- 0; c_b <- 0})
initialstate2 <- generateInitialState(n_species = pars2$n_species)
times2 <- 1:15

Sim2 <- simulateOneSeries(initialstate2, times = times2, pars = pars2,
                          processerror = F, obserror = F)

matplot(Sim2[,-1], type = "b", ylab="N",
        pch = rep(c("J", "A", "B"), each = pars2$n_species),
        col = 1:pars2$n_species, xlab = "time") # log='y'

```


```{r, echo=FALSE}
stanfit2 <- rstan::read_stan_csv(file.path(rootdir, "Fits.nosync", "Recovery", setup2$drawfile))
draws2 <- rstan::extract(stanfit2)

plotPredictedVsTrue(draws2, setup2$data)

```


```{r, warning=FALSE, results='hide', echo=FALSE}
## here are the drawn parameters:
setup2$metadata$stan_variables

plotEstimateVsTrue(parname = "b_log", simdata = setup2$data, stanfit = stanfit2)
plotEstimateVsTrue("c_j_log", setup2$data, stanfit2)
plotEstimateVsTrue("c_b_log", setup2$data, stanfit2)
plotEstimateVsTrue("g_logit", setup2$data, stanfit2)
plotEstimateVsTrue("h_logit", setup2$data, stanfit2) # best recovery
plotEstimateVsTrue("r_log", setup2$data, stanfit2)
plotEstimateVsTrue("s_log", setup2$data, stanfit2)

```



```{r, out.width='\\textwidth', fig.height = 8, fig.align='center', results=FALSE, warning=FALSE, echo=FALSE}
## plot correlations
setup2$metadata$stan_variables
corpars_a <- setup2$metadata$stan_variables[c(1, 4, 5, 7)]
corpars_b <- setup2$metadata$stan_variables[c(1, 4, 7, 8)]

pairs(stanfit2, pars = corpars_a)
pairs(stanfit2, pars = corpars_b)


```



### Setup 3

- Parameter configuration with c_j set to 0

```{r}

## Same parameters as above but with hard reset of c tp 0

# calcModelWrapper <- function(times, initialstate, pars, ...) { 
#   
#   calcModel(times, initialstate,
#             within(pars, { m_a <- 0;  m_j <- 0; c_j <- 0; c_a <- 0;}), # l <- 0;
#             ...)
#   }

setupbasename3 <- "Model_ba-rect-202105081104"
setup3 <- readRDS(file.path(rootdir, "Fits.nosync", "Recovery", paste0(setupbasename3, ".rds")))
pars3 <- within(setup3$truepars, { m_a <- 0;  m_j <- 0; c_j <- 0; c_a <- 0})
initialstate3 <- generateInitialState(n_species = pars3$n_species)
times3 <- 1:10

Sim3 <- simulateOneSeries(initialstate3, times = times3, pars = pars3,
                          processerror = F, obserror = F)

matplot(Sim3[,-1], type = "b", ylab="N",
        pch = rep(c("J", "A", "B"), each = pars3$n_species),
        col = 1:pars3$n_species, xlab = "time") # log='y'

```


```{r, echo=FALSE}
stanfit3 <- rstan::read_stan_csv(file.path(rootdir, "Fits.nosync", "Recovery", setup3$drawfile))
draws3 <- rstan::extract(stanfit3)

plotPredictedVsTrue(draws3, setup3$data)

```


```{r, warning=FALSE, results='hide', echo=FALSE}
## here are the drawn parameters:
setup3$metadata$stan_variables

plotEstimateVsTrue(parname = "b_log", simdata = setup3$data, stanfit = stanfit3)
plotEstimateVsTrue("c_b_log", setup3$data, stanfit3)
plotEstimateVsTrue("g_logit", setup3$data, stanfit3)
plotEstimateVsTrue("h_logit", setup3$data, stanfit3) # best recovery
plotEstimateVsTrue("r_log", setup3$data, stanfit3)
plotEstimateVsTrue("s_log", setup3$data, stanfit3)

```


```{r, out.width='\\textwidth', fig.height = 8, fig.align='center', results=FALSE, warning=FALSE, echo=FALSE}
## plot correlations
setup3$metadata$stan_variables
corpars_a <- setup3$metadata$stan_variables[c(1, 4, 5, 7)]
corpars_b <- setup3$metadata$stan_variables[c(1, 4, 7, 8)]

pairs(stanfit3, pars = corpars_a)
pairs(stanfit3, pars = corpars_b)


```




### Setup 4

- less J-dominated, s >> c_b
- with wider priors
    - common prior for most parameters
    - those for which a species-relative prior can be directly measured from the data: differentiated by species: b, h

```
  b_log ~ normal([0.3, 0.4], 0.1);
  h_logit ~ normal([0.4, 0.5], 0.1);
  
  g_logit ~ normal(-0.9, 1);
  r_log ~ normal(3, 1);
  s_log ~ normal(-1, 1);
```

```{r}

## Same parameters as above but with hard reset of c tp 0

setupbasename4 <- "Model_ba-rect-202105081530"
setup4 <- readRDS(file.path(rootdir, "Fits.nosync", "Recovery", paste0(setupbasename4, ".rds")))
pars4 <- within(setup3$truepars, { m_a <- 0;  m_j <- 0; c_j <- 0; c_a <- 0;})
initialstate4 <- generateInitialState(n_species = pars4$n_species)
times4 <- 1:10

Sim4 <- simulateOneSeries(initialstate4, times = times4, pars = pars4,
                          processerror = F, obserror = F)

matplot(Sim4[,-1], type = "b", ylab="N",
        pch = rep(c("J", "A", "B"), each = pars4$n_species),
        col = 1:pars4$n_species, xlab = "time") # log='y'

```


```{r, echo=FALSE}
stanfit4 <- rstan::read_stan_csv(file.path(rootdir, "Fits.nosync", "Recovery", setup4$drawfile))
draws4 <- rstan::extract(stanfit4)

plotPredictedVsTrue(draws4, setup4$data)

```


```{r, warning=FALSE, results='hide', echo=FALSE}
## here are the drawn parameters:
setup4$metadata$stan_variables

plotEstimateVsTrue(parname = "b_log", simdata = setup4$data, stanfit = stanfit4)
plotEstimateVsTrue("c_b_log", setup4$data, stanfit4)
plotEstimateVsTrue("g_logit", setup4$data, stanfit4)
plotEstimateVsTrue("h_logit", setup4$data, stanfit4) # best recovery
plotEstimateVsTrue("r_log", setup4$data, stanfit4)
plotEstimateVsTrue("s_log", setup4$data, stanfit4)

```



```{r, out.width='\\textwidth', fig.height = 8, fig.align='center', results=FALSE, warning=FALSE, echo=FALSE}
## plot correlations
setup4$metadata$stan_variables
corpars_a <- setup4$metadata$stan_variables[c(1, 4, 5, 7)]
corpars_b <- setup4$metadata$stan_variables[c(1, 4, 7, 8)]

pairs(stanfit4, pars = corpars_a)
pairs(stanfit4, pars = corpars_b)


```



### Setup 5
- 4. low J including c_j


 
## Further unsystematic recovery experience

### Possible problems with the discrete model
- suspicion: with state independent r == l the system might not be identifiable (WITH LIMITED DATA)
- with some parameter-configurations the discrete model has periodic fluctuations on the same scale as the error

### Success
- predictions always work


### Times
- just increasing the number of re-observations per time series does not always improve the fit dramatically
- (but in some cases it did)



### Regularization in hierarchical models

#### Constraints for sigma in lognormal
- These are notes from a former version with lognormal random demographic rates:
    - lognormal is fucked up because with big sigmas the mean gets highly biased towards greater values
        - Model gets ill-specified if sigma_par is not pushed towards 0
        - but regularization will introduce significant bias
        - => very soft prior sigma ~ normal(0, 1) [truncated]

#### Constraints for phi in negbinomial
- Really tight regularization on the observation error dispersion in phi_obs for recovery
- When in doubt, go tighter (higher): inv_phi_obs ~ normal(0, 0.001);
 
